#define _CRT_SECURE_NO_WARNINGS 1
//幸运的袋子
#include <bits/stdc++.h>

using namespace std;

// getLuckyPacket: 从当前位置开始搜索符合要求的组合，一直搜索到最后一个位置结束
// x[]: 袋子中的所有球
// n: 球的总数
// pos： 当前搜索的位置
// sum： 到目前位置的累加和
// multi： 到当前位置的累加值

int getLuckyPacket(int x[], int n, int pos, int sum, int multi) {
    int count = 0;
    // 循环搜索以位置 i 开始所有可能的组合
    for (int i = pos; i < n; ++i) {
        sum += x[i];
        multi *= x[i];
        if (sum > multi) {
            // 找到符合要求的组合，加1，继续累加后续的值，看是否有符合要求的集合
            count += 1 + getLuckyPacket(x, n, i + 1, sum, multi);
        }
        else if (x[i] == 1) {
            // 如果不符合要求，且当前元素值为1，则继续向后搜索
            count += getLuckyPacket(x, n, i + 1, sum, multi);
        }
        else {
            // 如果 sum 大于 multi，则后面就没有符合要求的组合了
            break;
        }
        // 要搜索下一个位置之前，首先恢复 sum 和 multi
        sum -= x[i];
        multi /= x[i];
        // 数字相同的球，没区别只能算作一个组合，所以直接跳过
        while (i < n - 1 && x[i] == x[i + 1]) {
            ++i;
        }
    }
    return count;
}

int main() {
    int n;
    while (cin >> n) {
        int x[n];
        for (int i = 0; i < n; ++i) {
            cin >> x[i];
        }
        sort(x, x + n);
        // 从第一个位置开始搜索
        cout << getLuckyPacket(x, n, 0, 0, 1) << endl;
    }
    return 0;
}


//计算日期的转换
#include<iostream>
#include<assert.h>
using namespace std;
int GetYearDay(int year, int month, int day)
{
    assert(month > 0 && month < 13);
    int sum = 0;
    int monthArray[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
    {
        monthArray[2] = 29;
    }
    for (int i = 1; i < month; i++)
    {
        sum += monthArray[i];
    }
    return sum + day;
}

int main()
{
    int year, month, day;
    cin >> year >> month >> day;
    cout << GetYearDay(year, month, day);
    return 0;
}